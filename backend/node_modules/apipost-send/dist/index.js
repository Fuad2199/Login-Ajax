'use strict';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var FileType = require('file-type'), setCookie = require('set-cookie-parser'), isImage = require('is-image'), fs = require('fs'), path = require('path'), isSvg = require('is-svg'), qs = require('querystring'), JSON5 = require('json5'), stripJsonComments = require("strip-json-comments"), ATools = require('apipost-tools'), Base64 = require('js-base64'), CryptoJS = require("crypto-js"), UrlParse = require('url-parse'), Hawk = require('hawk'), parsers = require('www-authenticate').parsers, _ = require('lodash'), aws4 = require('aws4'), EdgeGridAuth = require('akamai-edgegrid/src/auth'), ntlm = require('httpntlm').ntlm, crypto = require('crypto'), OAuth = require('oauth-1.0a'), MIMEType = require("whatwg-mimetype"), isBase64 = require('is-base64'), ASideTools = require('apipost-inside-tools'), minimatch = require('minimatch').minimatch, got = require('apipost-got'), tunnel = require('tunnel'), Validator = require('jsonschema').validate; require('pkginfo')(module); var mime = require('mime'), getObjFromRawHeaders = require("rawheaders2obj").getObjFromRawHeaders, FormData = require('form-data');
// Apipost 发送模块
var ApipostRequest = /** @class */ (function () {
    // 构造函数
    function ApipostRequest(opts) {
        if (!opts) {
            opts = {};
        }
        this.option = opts; // 初始化重定向
        // 配置项
        this.target_id = opts.target_id;
        this.isCloud = opts.hasOwnProperty('isCloud') ? (parseInt(opts.isCloud) > 0 ? 1 : -1) : -1; // update 0703
        this.requestLink = null;
        // 基本信息
        this.version = '0.0.100'; // update version for 7.0.13
        this.jsonschema = JSON.parse(fs.readFileSync(path.join(__dirname, './apipost-http-schema.json'), 'utf-8'));
    }
    // 结果转换函数
    ApipostRequest.prototype.ConvertResult = function (status, message, data) {
        return ASideTools.ConvertResult(status, message, data);
    };
    // 获取缓存目录
    ApipostRequest.prototype.getCachePath = function () {
        return ASideTools.getCachePath();
    };
    // 格式化 query 参数
    ApipostRequest.prototype.formatQueries = function (arr) {
        var queries = '';
        if (arr instanceof Array) {
            arr.forEach(function (item) {
                if (parseInt(item.is_checked) === 1) {
                    item.value;
                    if (item.value === '') {
                        queries += "".concat(item.key, "&");
                    }
                    else {
                        queries += "".concat(item.key, "=").concat(item.value, "&");
                    }
                }
            });
        }
        return qs.parse(_.trimEnd(queries, '&'));
    };
    // 用新的query对象(object)设置 uri 的query参数
    // return uri、host、path
    // setQueryString('https://echo.apipost.cn/get.php?id=1', {"id":[1,2], "token":3})
    // return {"uri":"https://echo.apipost.cn/get.php?id=1&id=2&token=3","host":"echo.apipost.cn","fullPath":"/get.php?id=1&id=2&token=3"}
    ApipostRequest.prototype.setQueryString = function (uri, paras) {
        var urls = new UrlParse(uri);
        var fullPath = urls.href.substr(urls.origin.length);
        var host = urls['host'];
        var baseUri = uri.substr(0, uri.indexOf(urls.query));
        if (urls.query !== '') {
            var queries = qs.parse(urls.query.substr(1));
            fullPath = urls['pathname'] + '?' + qs.stringify(Object.assign(queries, paras));
            uri = baseUri + '?' + qs.stringify(Object.assign(queries, paras));
        }
        else if (!_.isEmpty(paras)) {
            fullPath += '?' + qs.stringify(paras);
            uri += '?' + qs.stringify(paras);
        }
        return { uri: uri, host: host, fullPath: fullPath, baseUri: baseUri };
    };
    // 根据 auth 类型生成auth header参数
    ApipostRequest.prototype.createAuthHeaders = function (target) {
        var _a;
        var headers = {};
        var auth = target.request.auth;
        var _b = this.setQueryString(target.request.url, this.formatQueries(target.request.query.parameter)), uri = _b.uri, host = _b.host, fullPath = _b.fullPath; _b.baseUri;
        var entityBody = '';
        var rbody = this.formatRequestBodys(target);
        if (target.request.body.mode == 'urlencoded') {
            entityBody = rbody['form'];
        }
        else if (target.request.body.mode != 'form-data') {
            entityBody = rbody['body'];
        }
        try { // fixed 修复可能因第三方包报错导致的 bug
            switch (auth.type) {
                case 'noauth':
                    break;
                case 'kv':
                    if (_.trim(auth.kv.key) != '') {
                        headers[_.trim(auth.kv.key)] = auth.kv.value;
                    }
                    break;
                case 'bearer':
                    if (_.trim(auth.bearer.key) != '') {
                        headers['Authorization'] = "Bearer " + _.trim(auth.bearer.key);
                    }
                    break;
                case 'basic':
                    headers['Authorization'] = "Basic " + Base64.encode(auth.basic.username + ':' + auth.basic.password);
                    break;
                case 'digest':
                    var ha1 = '';
                    var ha2 = '';
                    var response = '';
                    var hashFunc = CryptoJS.MD5;
                    if (auth.digest.algorithm == 'MD5' || auth.digest.algorithm == 'MD5-sess') {
                        hashFunc = CryptoJS.MD5;
                    }
                    else if (auth.digest.algorithm == 'SHA-256' || auth.digest.algorithm == 'SHA-256-sess') {
                        hashFunc = CryptoJS.SHA256;
                    }
                    else if (auth.digest.algorithm == 'SHA-512' || auth.digest.algorithm == 'SHA-512-sess') {
                        hashFunc = CryptoJS.SHA512;
                    }
                    var cnonce = auth.digest.cnonce == '' ? 'apipost' : auth.digest.cnonce;
                    if (auth.digest.algorithm.substr(-5) == '-sess') {
                        ha1 = hashFunc(hashFunc(auth.digest.username + ':' + auth.digest.realm + ':' + auth.digest.password).toString() + ':' + auth.digest.nonce + ':' + cnonce).toString();
                    }
                    else {
                        ha1 = hashFunc(auth.digest.username + ':' + auth.digest.realm + ':' + auth.digest.password).toString();
                    }
                    if (auth.digest.qop != 'auth-int') {
                        ha2 = hashFunc(target.method + ':' + fullPath).toString();
                    }
                    else if (auth.digest.qop == 'auth-int') {
                        ha2 = hashFunc(target.method + ':' + fullPath + ':' + hashFunc(entityBody).toString()).toString();
                    }
                    if (auth.digest.qop == 'auth' || auth.digest.qop == 'auth-int') {
                        response = hashFunc(ha1 + ':' + auth.digest.nonce + ':' + (auth.digest.nc || '00000001') + ':' + cnonce + ':' + auth.digest.qop + ':' + ha2).toString();
                    }
                    else {
                        response = hashFunc(ha1 + ':' + auth.digest.nonce + ':' + ha2).toString();
                    }
                    headers['Authorization'] = "Digest username=\"" + auth.digest.username + "\", realm=\"" + auth.digest.realm + "\", nonce=\"" + auth.digest.nonce + "\", uri=\"" + fullPath + "\", algorithm=\"" + auth.digest.algorithm + "\", qop=\"" + auth.digest.qop + "\",nc=" + (auth.digest.nc || '00000001') + ", cnonce=\"" + cnonce + "\", response=\"" + response + "\", opaque=\"" + auth.digest.opaque + "\"";
                    break;
                case 'hawk':
                    var options = {
                        ext: auth.hawk.extraData,
                        timestamp: auth.hawk.timestamp,
                        nonce: auth.hawk.nonce,
                        // payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
                        // contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
                        // hash: false,
                        app: auth.hawk.app,
                        dlg: auth.hawk.delegation
                    };
                    if (auth.hawk.algorithm === '') {
                        auth.hawk.algorithm = 'sha256';
                    }
                    if (auth.hawk.authId !== '' && auth.hawk.authKey !== '') { // fix bug
                        var header = Hawk.client.header(uri, target.method, __assign({ credentials: {
                                id: auth.hawk.authId,
                                key: auth.hawk.authKey,
                                algorithm: auth.hawk.algorithm,
                            } }, options)).header;
                        headers['Authorization'] = header;
                    }
                    break;
                case 'awsv4':
                    var awsauth = aws4.sign({
                        method: target.method,
                        host: host,
                        path: fullPath,
                        service: auth.awsv4.service,
                        region: auth.awsv4.region,
                        body: entityBody
                    }, {
                        accessKeyId: auth.awsv4.accessKey,
                        secretAccessKey: auth.awsv4.secretKey,
                        sessionToken: auth.awsv4.sessionToken
                    });
                    Object.assign(headers, awsauth.headers);
                    break;
                case 'edgegrid':
                    var eg = EdgeGridAuth.generateAuth({
                        path: uri,
                        method: target.method,
                        headers: {},
                        body: entityBody
                    }, auth.edgegrid.clientToken, auth.edgegrid.clientSecret, auth.edgegrid.accessToken, auth.edgegrid.baseUri, 0, auth.edgegrid.nonce, auth.edgegrid.timestamp);
                    Object.assign(headers, eg.headers);
                    break;
                case 'ntlm': // https://github.com/SamDecrock/node-http-ntlm
                    Object.assign(headers, {
                        'Connection': 'keep-alive',
                        'Authorization': ntlm.createType1Message({
                            url: uri,
                            username: auth.ntlm.username,
                            password: auth.ntlm.password,
                            workstation: auth.ntlm.workstation,
                            domain: auth.ntlm.domain
                        })
                    });
                    break;
                case 'oauth1':
                    var hmac_1 = 'sha1';
                    if (auth.oauth1.signatureMethod === 'HMAC-SHA1') {
                        hmac_1 = 'sha1';
                    }
                    else if (auth.oauth1.signatureMethod === 'HMAC-SHA256') {
                        hmac_1 = 'sha256';
                    }
                    else if (auth.oauth1.signatureMethod === 'HMAC-SHA512') {
                        hmac_1 = 'sha512';
                    }
                    else {
                        // todo..
                        // 支持更多加密方式
                    }
                    var oauth = OAuth({
                        consumer: {
                            key: auth.oauth1.consumerKey,
                            secret: auth.oauth1.consumerSecret,
                            version: (_a = auth.oauth1.version) !== null && _a !== void 0 ? _a : '1.0',
                            nonce: auth.oauth1.nonce,
                            realm: auth.oauth1.realm,
                            timestamp: auth.oauth1.timestamp,
                            includeBodyHash: auth.oauth1.includeBodyHash,
                        },
                        signature_method: auth.oauth1.signatureMethod,
                        hash_function: function (base_string, key) {
                            var hash = crypto.createHmac(hmac_1, key).update(base_string).digest('base64');
                            return hash;
                        },
                    });
                    var request_data = {
                        url: uri,
                        method: target.method,
                        data: auth.oauth1.includeBodyHash ? entityBody : {},
                        oauth_callback: auth.oauth1.callback
                    };
                    var token = {
                        key: auth.oauth1.token,
                        secret: auth.oauth1.tokenSecret,
                    };
                    Object.assign(headers, oauth.toHeader(oauth.authorize(request_data, token)));
                    break;
            }
        }
        catch (e) { }
        return headers;
    };
    // 格式化headers参数
    ApipostRequest.prototype.formatRequestHeaders = function (arr, mode) {
        var headers = {
            "User-Agent": "PostmanRuntime-ApipostRuntime/1.1.0",
            "Cache-Control": "no-cache"
        };
        switch (mode) {
            case "json":
                headers['content-type'] = "application/json";
                break;
            case "xml":
                headers['content-type'] = "application/xml";
                break;
            case "javascript":
                headers['content-type'] = "application/javascript";
                break;
            case "plain":
                headers['content-type'] = "text/plain";
                break;
            case "html":
                headers['content-type'] = "text/html";
                break;
        }
        if (arr instanceof Array) {
            arr.forEach(function (item) {
                if (parseInt(item.is_checked) === 1 && _.trim(item.key) != '') {
                    var headerKey_1 = item.key;
                    _.mapKeys(headers, function (v, k) {
                        if (_.toLower(k) == _.toLower(headerKey_1)) {
                            delete headers[k];
                        }
                    });
                    headers[_.trim(headerKey_1)] = item.value;
                }
            });
        }
        return headers;
    };
    // 格式化 urlencode 参数
    ApipostRequest.prototype.formatUrlencodeBodys = function (arr) {
        var bodys = '';
        if (arr instanceof Array) {
            arr.forEach(function (item) {
                if (parseInt(item.is_checked) === 1) {
                    if (item.key !== '') {
                        bodys += encodeURIComponent(item.key) + '=' + encodeURIComponent(item.value) + '&';
                        // bodys += item.key + '=' + item.value + '&';
                    }
                }
            });
        }
        bodys = bodys.substr(-1) == '&' ? bodys.substr(0, bodys.length - 1) : bodys;
        return bodys;
    };
    ApipostRequest.prototype.getBase64Mime = function (dataurl) {
        try {
            var arr = dataurl.split(','), mime_1 = arr[0].match(/:(.*?);/)[1];
            if (mime_1) {
                var mimeType = new MIMEType(mime_1);
                return { ext: mimeType['_subtype'], mime: mimeType.essence };
            }
            else {
                return null;
            }
        }
        catch (error) {
            return null;
        }
    };
    // 格式化 FormData 参数
    ApipostRequest.prototype.formatFormDataBodys = function (forms, arr) {
        var that = this;
        if (arr instanceof Array) {
            arr.forEach(function (item) {
                if (parseInt(item.is_checked) === 1) {
                    var options_1 = {};
                    if (typeof item.contentType === 'string') {
                        options_1['contentType'] = item.contentType;
                    }
                    if (item.type === 'File') {
                        if (_.isArray(item === null || item === void 0 ? void 0 : item.value) && item.value.length > 0) {
                            item.value.forEach(function (path) {
                                try {
                                    if (item.key !== '') {
                                        forms.append(item.key, fs.createReadStream(path), options_1);
                                    }
                                }
                                catch (error) {
                                }
                            });
                        }
                        else if (_.isArray(item === null || item === void 0 ? void 0 : item.fileBase64) && item.fileBase64.length > 0) {
                            var _file_names_1 = typeof item.filename == 'string' ? item.filename.split('|') : [];
                            var _i_1 = 0;
                            item.fileBase64.forEach(function (base64) {
                                var fileBase64 = (isBase64(base64, { allowEmpty: false, allowMime: true }) || base64.indexOf('base64,') > 0) ? base64 : (isBase64(item.value, { allowEmpty: false, allowMime: true }) ? item.value : '');
                                if (isBase64(fileBase64, { allowEmpty: false, allowMime: true }) || base64.indexOf('base64,') > 0) { // 云端
                                    var _mime = that.getBase64Mime(fileBase64);
                                    var _temp_file = path.join(path.resolve(that.getCachePath()), "cache_".concat(CryptoJS.MD5(fileBase64).toString()));
                                    try {
                                        fs.accessSync(_temp_file);
                                    }
                                    catch (err) {
                                        try {
                                            fs.mkdirSync(_temp_file, { recursive: true });
                                        }
                                        catch (e) { }
                                    }
                                    if (typeof _file_names_1[_i_1] == 'string') {
                                        _temp_file = path.join(_temp_file, "".concat(_file_names_1[_i_1]));
                                    }
                                    else {
                                        _temp_file = path.join(_temp_file, "".concat(CryptoJS.MD5(item.key).toString(), ".").concat(_mime ? _mime.ext : 'unknown'));
                                    }
                                    fs.writeFileSync(_temp_file, Buffer.from(fileBase64.replace(/^data:(.+?);base64,/, ''), 'base64'));
                                    if (item.key !== '') {
                                        forms.append(item.key, fs.createReadStream(_temp_file), options_1);
                                    }
                                    // fs.unlink(_temp_file, () => { }); // fix 文件上传bug
                                }
                                _i_1++;
                            });
                        }
                    }
                    else {
                        if (item.key !== '') {
                            forms.append(item.key, item.value, options_1);
                        }
                    }
                }
            });
        }
        return forms;
    };
    // 格式化 json 参数
    ApipostRequest.prototype.formatRawJsonBodys = function (raw) {
        if (raw === void 0) { raw = ''; }
        var bodys = '';
        if (ATools.isJson5(raw)) {
            try {
                bodys = stripJsonComments(raw);
                //                 bodys = JSONbig.stringify(JSONbig.parse(stripJsonComments(raw)));
            }
            catch (e) {
                bodys = JSON.stringify(JSON5.parse(raw));
            }
        }
        else {
            bodys = raw;
        }
        return bodys;
    };
    // 格式化 其他 非json raw参数
    ApipostRequest.prototype.formatRawBodys = function (raw) {
        if (raw === void 0) { raw = ''; }
        var bodys = raw;
        // if(ATools.isJson5(raw)){
        //     bodys = JSON.stringify(JSON5.parse(raw));
        // }else{
        //     bodys = raw;
        // }
        return bodys;
    };
    // 格式化 请求Body 参数
    ApipostRequest.prototype.formatRequestBodys = function (target) {
        var _body = {}, that = this;
        switch (_.get(target, 'request.body.mode')) {
            case "none":
                break;
            case "form-data":
                try {
                    var form = new FormData();
                    this.formatFormDataBodys(form, target.request.body.parameter);
                    _body = {
                        body: form,
                        header: form.getHeaders()
                    };
                }
                catch (e) {
                    _body = {
                        error: String(e)
                    };
                }
                break;
            case "urlencoded":
                _body = {
                    body: this.formatUrlencodeBodys(target.request.body.parameter),
                    header: {
                        "content-type": "application/x-www-form-urlencoded"
                    }
                };
                break;
            case "binary":
                var binary = _.get(target, 'request.body.binary');
                if (_.isObject(binary)) {
                    var filePath = String(_.get(binary, 'file_path'));
                    var base64Data = String(_.get(binary, 'data_url'));
                    try {
                        if (base64Data != '' && base64Data.indexOf('base64,') > 0) {
                            if (isBase64(base64Data, { allowEmpty: false, allowMime: true })) {
                                _body = {
                                    body: Buffer.from(base64Data.replace(/^data:(.+?);base64,/, ''), 'base64'),
                                    header: {
                                        "content-type": _.get(that.getBase64Mime(base64Data), 'mime') || 'application/octet-stream'
                                    }
                                };
                            }
                        }
                        else if (_.isString(filePath) && filePath != '') {
                            var binaryBuffer = fs.createReadStream(filePath);
                            if (_.isBuffer(binaryBuffer)) {
                                _body = {
                                    body: binaryBuffer,
                                    header: {
                                        "content-type": mime.getType(filePath) || 'application/octet-stream'
                                    }
                                };
                            }
                        }
                    }
                    catch (e) {
                        _body = {
                            error: String(e)
                        };
                    }
                }
                break;
            case "json":
                _body = {
                    body: this.formatRawJsonBodys(target.request.body.raw)
                };
                break;
            default:
                _body = {
                    body: this.formatRawBodys(target.request.body.raw)
                };
                break;
        }
        return _body;
    };
    // 格式化 请求Body 参数（用于脚本使用）
    ApipostRequest.prototype.formatDisplayRequestBodys = function (target) {
        var _body = {
            'request_bodys': {},
            'raw': {
                'mode': 'none'
            }
        };
        var arr = _.cloneDeep(_.get(target, 'request.body.parameter'));
        switch (_.get(target, 'request.body.mode')) {
            case "none":
                _body = {
                    'request_bodys': '',
                    'raw': {
                        'mode': 'none'
                    }
                };
                break;
            case "form-data":
                if (arr instanceof Array) {
                    var _raw_1 = [];
                    arr.forEach(function (item) {
                        if (parseInt(item.is_checked) === 1) {
                            _body.request_bodys[item.key] = item.value;
                            if (item.type === 'File') {
                                _raw_1.push({
                                    key: item.key,
                                    type: 'file',
                                    src: item.value
                                });
                            }
                            else {
                                _raw_1.push({
                                    key: item.key,
                                    type: "text",
                                    value: item.value
                                });
                            }
                        }
                    });
                    _body.raw = {
                        'mode': 'formdata',
                        'formdata': _raw_1
                    };
                }
                break;
            case "urlencoded":
                if (arr instanceof Array) {
                    var _raw_2 = [];
                    arr.forEach(function (item) {
                        if (parseInt(item.is_checked) === 1) {
                            _body.request_bodys[item.key] = item.value;
                            _raw_2.push({
                                key: item.key,
                                value: item.value
                            });
                        }
                    });
                    _body.raw = {
                        'mode': 'urlencoded',
                        'urlencoded': _raw_2
                    };
                }
                break;
            default:
                _body = {
                    'request_bodys': this.formatRawJsonBodys(target.request.body.raw),
                    'raw': {
                        'mode': 'raw',
                        'raw': this.formatRawJsonBodys(target.request.body.raw),
                        'options': {
                            'raw': {
                                'language': target.request.body.mode
                            }
                        }
                    }
                };
                break;
        }
        return _body;
    };
    // 响应时间点
    ApipostRequest.prototype.responseAt = function () {
        var time = new Date();
        var h = time.getHours();
        h = h < 10 ? '0' + h : h;
        var m = time.getMinutes();
        m = m < 10 ? '0' + m : m;
        var s = time.getSeconds();
        s = s < 10 ? '0' + s : s;
        return h + ':' + m + ':' + s;
    };
    // 不区分大小写的 _.get
    ApipostRequest.prototype.getCaseInsensitive = function (object, keyToFind) {
        try {
            // 先将要查找的键转换成小写
            var lowerKey = keyToFind.toLowerCase();
            if (!_.isObject(object)) {
                return undefined;
            }
            // 在对象的所有键中查找
            for (var key in object) {
                if (key.toLowerCase() === lowerKey) {
                    return object[key];
                }
            }
        }
        catch (e) { }
        // 如果没有找到，返回undefined
        return undefined;
    };
    // 不区分大小写的 _.set
    ApipostRequest.prototype.setCaseInsensitive = function (obj, path, value) {
        if (typeof path === 'string') {
            // 把点路径转换为数组形式，以处理嵌套对象
            path = _.toPath(path);
            // 变量lastKey持有最后一个键，我们需要在后面步骤中用它来设置值
            var lastKey = path.pop();
            // 寻找路径中匹配的键，不区分大小写
            path = path.map(function (segment) {
                var key = Object.keys(obj).find(function (objKey) { return objKey.toLowerCase() === segment.toLowerCase(); });
                return key || segment;
            });
            // 把最后一个键加回到路径中
            path.push(lastKey);
            // 使用lodash的_.set来设置值
            _.set(obj, path, value);
        }
        else {
            // 如果path不是字符串，假设它是正确的路径数组
            _.set(obj, path, value);
        }
    };
    // 生成digest认证头
    ApipostRequest.prototype.getDigestAuthString = function (target, method, fullPath, digest) {
        var ha1 = '', ha2 = '', response = '', hashFunc = CryptoJS.MD5;
        var entityBody = _.get(this.formatRequestBodys(target), 'body') || '';
        if (digest.algorithm == 'MD5' || digest.algorithm == 'MD5-sess') {
            hashFunc = CryptoJS.MD5;
        }
        else if (digest.algorithm == 'SHA-256' || digest.algorithm == 'SHA-256-sess') {
            hashFunc = CryptoJS.SHA256;
        }
        else if (digest.algorithm == 'SHA-512' || digest.algorithm == 'SHA-512-sess') {
            hashFunc = CryptoJS.SHA512;
        }
        var cnonce = digest.cnonce == '' ? 'apipost' : digest.cnonce;
        if (digest.algorithm.substr(-5) == '-sess') {
            ha1 = hashFunc(hashFunc(digest.username + ':' + digest.realm + ':' + digest.password).toString() + ':' + digest.nonce + ':' + cnonce).toString();
        }
        else {
            ha1 = hashFunc(digest.username + ':' + digest.realm + ':' + digest.password).toString();
        }
        if (digest.qop != 'auth-int') {
            ha2 = hashFunc(method + ':' + fullPath).toString();
        }
        else if (digest.qop == 'auth-int') {
            ha2 = hashFunc(method + ':' + fullPath + ':' + hashFunc(entityBody).toString()).toString();
        }
        if (digest.qop == 'auth' || digest.qop == 'auth-int') {
            response = hashFunc(ha1 + ':' + digest.nonce + ':' + (digest.nc || '00000001') + ':' + cnonce + ':' + digest.qop + ':' + ha2).toString();
        }
        else {
            response = hashFunc(ha1 + ':' + digest.nonce + ':' + ha2).toString();
        }
        return "Digest username=\"" + digest.username + "\", realm=\"" + digest.realm + "\", nonce=\"" + digest.nonce + "\", uri=\"" + fullPath + "\", algorithm=\"" + digest.algorithm + "\", qop=\"" + digest.qop + "\",nc=" + (digest.nc || '00000001') + ", cnonce=\"" + cnonce + "\", response=\"" + response + "\", opaque=\"" + digest.opaque + "\"";
    };
    //生成ntlm认证头
    ApipostRequest.prototype.getNTLMAuthString = function (target, type2msg, ntlm) {
        var uri = this.setQueryString(target.request.url, this.formatQueries(target.request.query.parameter)).uri;
        return ntlm.createType3Message(type2msg, {
            url: uri,
            username: ntlm.username,
            password: ntlm.password,
            workstation: ntlm.workstation,
            domain: ntlm.domain
        });
    };
    // 处理 响应参数
    ApipostRequest.prototype.formatResponseData = function (error, response, target) {
        return __awaiter(this, void 0, void 0, function () {
            var uri, protocol, target_id, requestBody, result, responseAt, rawCookies, resMime, fileTypeMime, contentType, ext, fileName;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        uri = _.get(response, 'request.options.url');
                        protocol = _.get(uri, 'protocol') == 'https:' ? 'https' : 'http';
                        target_id = _.get(target, 'target_id');
                        requestBody = this.formatDisplayRequestBodys(target);
                        result = {
                            error: error,
                            request: {
                                "url": String(uri),
                                "uri": uri,
                                "method": _.get(response, 'request.options.method'),
                                "timeout": parseInt(_.get(response, 'request.options.timeout.request')) || 0,
                                "contentType": this.getCaseInsensitive(_.get(response, 'request.options.headers') || {}, 'content-type') || 'none',
                                "header": _.map(_.get(response, 'request.options.headers'), function (value, key) { return ({ key: key, value: value }); }),
                                "proxy": _.get(response, "request.options.agent.".concat(protocol, ".proxyOptions")) || null,
                                "httpVersion": _.get(response, 'httpVersion'),
                                "request_headers": _.get(response, 'request.options.headers'),
                                "request_bodys": _.get(requestBody, 'raw'),
                                "body": _.get(requestBody, 'raw')
                            },
                            response: {}
                        };
                        responseAt = this.responseAt();
                        _.assign(result, {
                            response: {
                                "target_id": target_id,
                                "responseTime": _.get(response, 'timings.phases.total') || '0.00',
                                "responseSize": _.round((this.getCaseInsensitive(_.get(response, 'headers'), 'content-length') || String(_.get(response, 'body')).length) / 1024, 2),
                                "resposneAt": responseAt,
                                "responseAt": responseAt,
                                "netWork": {
                                    "agent": _.get(response, "request.options.agent.".concat(protocol, ".proxyOptions")) || null,
                                    "address": {
                                        "remote": {
                                            "address": _.get(response, 'ip')
                                        }
                                    }
                                },
                                "status": _.get(response, 'statusMessage') || '',
                                "code": _.get(response, 'statusCode') || 0,
                                "timingPhases": _.get(response, 'timings.phases') || {},
                                "resHeaders": getObjFromRawHeaders(_.get(response, 'rawHeaders') || []) || {},
                                "headers": getObjFromRawHeaders(_.get(response, 'rawHeaders') || []) || {},
                                "header": _.map(getObjFromRawHeaders(_.get(response, 'rawHeaders') || []) || {}, function (value, key) { return ({ key: key, value: value }); }) || [],
                                "rawCookies": [],
                                "resCookies": [],
                                "cookies": {},
                                "rawBody": String(_.get(response, 'body')) || '',
                                "stream": {
                                    "type": "Buffer",
                                    "data": _.get(response, 'body')
                                },
                                "fitForShow": "Monaco",
                                "resMime": {
                                    "ext": "json",
                                    "mime": "application/json"
                                },
                                "raw": {
                                    "status": _.get(response, 'statusMessage'),
                                    "responseTime": _.get(response, 'timings.phases.total'),
                                    "type": "json",
                                    "responseText": String(_.get(response, 'body'))
                                },
                                "json": {},
                                "filename": ""
                            }
                        });
                        // 设置 cookie
                        if (_.isArray(this.getCaseInsensitive(_.get(response, 'headers'), 'set-cookie'))) {
                            rawCookies = setCookie.parse(this.getCaseInsensitive(_.get(response, 'headers'), 'set-cookie'));
                            _.assign(result.response, {
                                rawCookies: rawCookies,
                                resCookies: rawCookies
                            });
                        }
                        if (_.isArray(_.get(result, "response.rawCookies"))) {
                            _.assign(result.response, {
                                cookies: _.reduce(_.get(result, "response.rawCookies"), function (result, cookie) {
                                    result[cookie.name] = cookie.value;
                                    return result;
                                }, {})
                            });
                        }
                        // 设置json
                        try {
                            _.assign(result.response, {
                                json: JSON5.parse(String(_.get(response, 'body')))
                            });
                        }
                        catch (e) { }
                        resMime = {
                            "ext": "json",
                            "mime": "application/json"
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        if (!isSvg(_.get(response, 'body').toString())) return [3 /*break*/, 2];
                        _.assign(resMime, {
                            ext: "svg",
                            mime: "image/svg+xml"
                        });
                        _.assign(result.response, {
                            fitForShow: 'Image'
                        });
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, FileType.fromBuffer(_.get(response, 'body'))];
                    case 3:
                        fileTypeMime = _a.sent();
                        if (_.isObject(fileTypeMime)) {
                            _.assign(resMime, fileTypeMime);
                            if (isImage("test.".concat(resMime.ext))) {
                                _.assign(result.response, {
                                    fitForShow: 'Image'
                                });
                            }
                            else if (resMime.ext == 'pdf') {
                                _.assign(result.response, {
                                    fitForShow: 'Pdf'
                                });
                            }
                            else {
                                _.assign(result.response, {
                                    fitForShow: 'Other'
                                });
                            }
                        }
                        else {
                            contentType = this.getCaseInsensitive(_.get(response, 'headers') || {}, 'content-type') || '';
                            if (!_.isEmpty(contentType)) {
                                _.assign(resMime, {
                                    ext: mime.getExtension(contentType),
                                    mime: mime.getType(mime.getExtension(contentType))
                                });
                            }
                            else {
                                ext = ATools.isJson(result.response.rawBody) ? 'json' : ATools.isJsonp(result.response.rawBody) ? 'jsonp' : 'html';
                                _.assign(resMime, {
                                    ext: ext,
                                    mime: mime.getType(ext) || 'application/jsonp'
                                });
                            }
                            _.assign(result.response, {
                                fitForShow: 'Monaco'
                            });
                        }
                        _a.label = 4;
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 6:
                        _.assign(result.response, {
                            resMime: resMime
                        });
                        // 缓存文件名
                        if (!_.isEmpty(_.get(process, 'versions.electron'))) {
                            fileName = _.get(this.getCaseInsensitive(_.get(response, 'headers') || {}, 'content-disposition'), 'parameters.filename');
                            try {
                                if (_.isString(fileName)) {
                                    fileName = decodeURIComponent(fileName);
                                }
                                else {
                                    fileName = "".concat(target_id, ".").concat(_.get(result, 'response.resMime.ext'));
                                }
                            }
                            catch (e) { }
                            try {
                                fileName = path.join(path.resolve(this.getCachePath()), fileName);
                                fs.writeFileSync(fileName, _.get(response, 'body'));
                                _.assign(result.response, {
                                    filename: fileName
                                });
                            }
                            catch (e) { }
                        }
                        // 重置响应内容
                        _.set(result, 'response.raw.type', _.get(result, 'response.resMime.ext'));
                        if (_.get(result, 'response.fitForShow') != 'Monaco') {
                            _.set(result, 'response.rawBody', '');
                            _.set(result, 'response.raw.responseText', '');
                        }
                        return [2 /*return*/, new Promise(function (resolve) {
                                resolve(result);
                            })];
                }
            });
        });
    };
    // 取消发送
    ApipostRequest.prototype.abort = function () {
        try {
            if (_.isObject(this.requestLink) && _.isFunction(this.requestLink.cancel)) {
                this.requestLink.cancel();
            }
        }
        catch (e) { }
    };
    // 发送
    ApipostRequest.prototype.request = function (target, extra_headers) {
        return __awaiter(this, void 0, void 0, function () {
            var that;
            var _this = this;
            return __generator(this, function (_a) {
                that = this;
                return [2 /*return*/, new Promise(function (reslove, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var valid_res, err_msg, query_add_equal, request_urls_1, authHeaders, options_2, protocol, https_1, cacert_path, cacert_base64, cert_1, passphrase, proxy, host, port, match, bypass, bypassMatch, protocols, protocolMatch, no_proxy, env_proxy, env_proxy_parse, value, match, searchParams_1, formatRequestBodys, requestError, requestContentType, requestBody, ctKey, request_urls_clone, got_url, queryStr, queries;
                        var _this = this;
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    valid_res = Validator(target, that.jsonschema);
                                    if (!!valid_res.valid) return [3 /*break*/, 1];
                                    console.error({
                                        target: target,
                                        status: 'error'
                                    });
                                    err_msg = "";
                                    if (valid_res.errors.length > 0) {
                                        err_msg = valid_res.errors[0].path.join(".") + "->" + valid_res.errors[0].message;
                                    }
                                    reject(that.ConvertResult('error', "\u9519\u8BEF\u7684\u8BF7\u6C42\u6570\u636E\u683C\u5F0F\uFF0C\u9519\u8BEF\u8BE6\u60C5:".concat(err_msg)));
                                    return [3 /*break*/, 9];
                                case 1:
                                    query_add_equal = 1;
                                    if ((_a = target === null || target === void 0 ? void 0 : target.request) === null || _a === void 0 ? void 0 : _a.query_add_equal) {
                                        query_add_equal = target.request.query_add_equal == 1 ? 1 : -1;
                                    }
                                    request_urls_1 = new UrlParse(_.get(target, 'request.url'));
                                    if (_.isEmpty(request_urls_1 === null || request_urls_1 === void 0 ? void 0 : request_urls_1.port)) {
                                        _.assign(request_urls_1, {
                                            port: (request_urls_1 === null || request_urls_1 === void 0 ? void 0 : request_urls_1.protocol) == 'https:' ? 443 : 80
                                        });
                                    }
                                    authHeaders = that.createAuthHeaders(target);
                                    options_2 = {
                                        throwHttpErrors: false,
                                        method: _.get(target, 'method') || 'GET',
                                        allowGetBody: true,
                                        headers: __assign({}, authHeaders),
                                        responseType: "buffer",
                                        ignoreInvalidCookies: true,
                                        decompress: true,
                                        http2: false,
                                        // 以下为重试设置
                                        retry: 0,
                                        // 以下为重定向设置
                                        followRedirect: false,
                                        methodRewriting: false,
                                        maxRedirects: 10,
                                        timeout: 10000,
                                    };
                                    // 设置超时时间
                                    if (parseInt(_.get(that.option, 'timeout')) > 0) {
                                        _.assign(options_2, {
                                            timeout: parseInt(_.get(that.option, 'timeout'))
                                        });
                                    }
                                    // 是否开启重定向
                                    if (parseInt(_.get(that.option, 'followRedirect')) > 0) {
                                        _.assign(options_2, {
                                            followRedirect: true
                                        });
                                        if (parseInt(_.get(that.option, 'methodRewriting')) > 0) {
                                            _.assign(options_2, {
                                                methodRewriting: true
                                            });
                                        }
                                        if (parseInt(_.get(that.option, 'maxrequstloop')) > 0) {
                                            _.assign(options_2, {
                                                maxRedirects: parseInt(_.get(that.option, 'maxrequstloop'))
                                            });
                                        }
                                    }
                                    protocol = (target === null || target === void 0 ? void 0 : target.protocol) ? target.protocol : _.get(target, 'request.protocol');
                                    if (protocol == 'http/2') {
                                        _.assign(options_2, {
                                            http2: true
                                        });
                                    }
                                    https_1 = {
                                        rejectUnauthorized: false
                                    };
                                    // ca 证书
                                    if (_.get(that.option, 'ca_cert.open') > 0) {
                                        cacert_path = _.get(that.option, 'ca_cert.path');
                                        cacert_base64 = String(_.get(that.option, 'ca_cert.base64')).replace(/^data:.*?;base64,/, '');
                                        if (isBase64(cacert_base64, { allowEmpty: false })) {
                                            _.assign(https_1, {
                                                certificateAuthority: Buffer.from(cacert_base64, 'base64')
                                            });
                                        }
                                        else {
                                            if (_.isString(cacert_path) && !_.isEmpty(cacert_path)) {
                                                try {
                                                    fs.accessSync(cacert_path);
                                                    _.assign(https_1, {
                                                        certificateAuthority: fs.readFileSync(cacert_path)
                                                    });
                                                }
                                                catch (e) { }
                                            }
                                        }
                                    }
                                    // 客户端证书
                                    try {
                                        if (_.isObject(_.get(that.option, 'client_cert'))) {
                                            cert_1 = _.find(_.get(that.option, 'client_cert'), function (item) {
                                                var cert_urls = new UrlParse(item === null || item === void 0 ? void 0 : item.HOST);
                                                if (request_urls_1.protocol == 'http://' && request_urls_1.port == '') {
                                                    request_urls_1.port = 80;
                                                }
                                                if (cert_urls.protocol == 'http://' && cert_urls.port == '') {
                                                    cert_urls.port = 80;
                                                }
                                                if (request_urls_1.protocol == 'https://' && request_urls_1.port == '') {
                                                    request_urls_1.port = 443;
                                                }
                                                if (cert_urls.protocol == 'https://' && cert_urls.port == '') {
                                                    cert_urls.port = 443;
                                                }
                                                return request_urls_1.protocol == cert_urls.protocol && request_urls_1.hostname == cert_urls.hostname && request_urls_1.port == cert_urls.port;
                                            });
                                            if (_.isObject(cert_1) && !_.isEmpty(cert_1)) {
                                                _.forEach({ key: "KEY", pfx: "PFX", certificate: "CRT" }, function (cp, key) {
                                                    var _path = _.get(cert_1, "".concat(cp, ".FILE_URL"));
                                                    var _base64 = String(_.get(cert_1, "".concat(cp, ".FILE_BASE64"))).replace(/^data:.*?;base64,/, '');
                                                    if (isBase64(_base64, { allowEmpty: false })) {
                                                        https_1[key] = Buffer.from(_base64, 'base64');
                                                    }
                                                    else {
                                                        if (_.isString(_path) && !_.isEmpty(_path)) {
                                                            try {
                                                                fs.accessSync(_path);
                                                                https_1[key] = fs.readFileSync(_path);
                                                            }
                                                            catch (e) { }
                                                        }
                                                    }
                                                });
                                                passphrase = _.get(cert_1, 'PASSWORD');
                                                if (_.isString(passphrase) && !_.isEmpty(passphrase)) {
                                                    _.assign(https_1, {
                                                        passphrase: passphrase
                                                    });
                                                }
                                            }
                                        }
                                    }
                                    catch (e) { }
                                    _.assign(options_2, {
                                        https: https_1
                                    });
                                    if (!((options_2 === null || options_2 === void 0 ? void 0 : options_2.http2) == false)) return [3 /*break*/, 8];
                                    proxy = {}, host = '', port = 0;
                                    if (!(_.get(that.option, 'proxy.type') == 1)) return [3 /*break*/, 2];
                                    match = _.get(that.option, 'proxy.auth.host').match(/(([^:]+):(\d+))/);
                                    if (_.isArray(match) && parseInt(match[3], 10) > 0) {
                                        host = match[2];
                                        port = parseInt(match[3]);
                                    }
                                    bypass = _.get(that.option, 'proxy.bypass');
                                    if (_.isString(bypass)) {
                                        bypass = bypass.split(',');
                                    }
                                    bypassMatch = _.find(bypass, function (o) {
                                        return minimatch(_.toLower(request_urls_1 === null || request_urls_1 === void 0 ? void 0 : request_urls_1.host), o);
                                    });
                                    if (bypassMatch) {
                                        host = '';
                                        port = 0;
                                    }
                                    else {
                                        protocols = _.get(that.option, 'proxy.protocols');
                                        if (_.isString(protocols)) {
                                            protocols = protocols.split(",");
                                        }
                                        protocolMatch = _.find(protocols, function (o) {
                                            return _.toLower(request_urls_1 === null || request_urls_1 === void 0 ? void 0 : request_urls_1.protocol) == "".concat(o, ":");
                                        });
                                        if (!protocolMatch) {
                                            host = '';
                                            port = 0;
                                        }
                                    }
                                    return [3 /*break*/, 7];
                                case 2:
                                    if (!(_.get(that.option, 'proxy.type') == -1)) return [3 /*break*/, 7];
                                    no_proxy = _.isString(_.get(process, 'env.NO_PROXY')) && _.get(that.option, 'proxy.envfirst') > 0 ? String(_.get(process, 'env.NO_PROXY')).split(",") : [];
                                    if (!(_.isEmpty(no_proxy) || _.isUndefined(_.find(no_proxy, function (o) {
                                        return minimatch(_.toLower(request_urls_1 === null || request_urls_1 === void 0 ? void 0 : request_urls_1.host), o);
                                    })))) return [3 /*break*/, 7];
                                    if (!(_.get(that.option, 'proxy.envfirst') > 0 || _.isEmpty(_.get(process, 'versions.electron')))) return [3 /*break*/, 3];
                                    env_proxy = String((request_urls_1 === null || request_urls_1 === void 0 ? void 0 : request_urls_1.protocol) == 'https:' ? _.get(process, 'env.HTTPS_PROXY') : _.get(process, 'env.HTTP_PROXY'));
                                    if (!_.isEmpty(env_proxy)) {
                                        env_proxy_parse = new UrlParse(env_proxy);
                                        host = (env_proxy_parse === null || env_proxy_parse === void 0 ? void 0 : env_proxy_parse.hostname) || '';
                                        port = parseInt(env_proxy_parse === null || env_proxy_parse === void 0 ? void 0 : env_proxy_parse.port, 10) > 0 ? parseInt(env_proxy_parse === null || env_proxy_parse === void 0 ? void 0 : env_proxy_parse.port, 10) : 0;
                                    }
                                    return [3 /*break*/, 7];
                                case 3:
                                    if (!!_.isEmpty(_.get(process, 'versions.electron'))) return [3 /*break*/, 7];
                                    _b.label = 4;
                                case 4:
                                    _b.trys.push([4, 6, , 7]);
                                    return [4 /*yield*/, require('electron').session.defaultSession.resolveProxy(_.get(target, 'request.url'))];
                                case 5:
                                    value = _b.sent();
                                    match = value.match(/PROXY (([^:]+):(\d+))/);
                                    if (_.isObject(match) && _.isString(match[2]) && !_.isEmpty(match[2]) && parseInt(match[3], 10) > 0) {
                                        host = match[2];
                                        port = parseInt(match[3], 10);
                                    }
                                    return [3 /*break*/, 7];
                                case 6:
                                    _b.sent();
                                    return [3 /*break*/, 7];
                                case 7:
                                    if (!_.isEmpty(host) && port > 0) {
                                        _.assign(proxy, {
                                            host: host,
                                            port: port
                                        });
                                        if (_.get(that.option, 'proxy.auth.authenticate') > 0) {
                                            if (_.get(that.option, 'proxy.auth.username') != '') {
                                                _.assign(proxy, {
                                                    proxyAuth: "".concat(_.get(that.option, 'proxy.auth.username'), ":").concat(_.get(that.option, 'proxy.auth.password'))
                                                });
                                            }
                                        }
                                        if ((request_urls_1 === null || request_urls_1 === void 0 ? void 0 : request_urls_1.protocol) == 'https:') {
                                            _.assign(options_2, {
                                                agent: {
                                                    https: tunnel.httpsOverHttp({
                                                        proxy: proxy
                                                    })
                                                }
                                            });
                                        }
                                        else {
                                            _.assign(options_2, {
                                                agent: {
                                                    http: tunnel.httpOverHttp({
                                                        proxy: proxy
                                                    })
                                                }
                                            });
                                        }
                                    }
                                    _b.label = 8;
                                case 8:
                                    searchParams_1 = {};
                                    _.forEach(_.get(target, 'request.query.parameter'), function (item) {
                                        if (item.is_checked > 0 && !_.isEmpty(item.key)) {
                                            searchParams_1[item.key] = item.value;
                                        }
                                    });
                                    formatRequestBodys = that.formatRequestBodys(target), requestError = _.get(formatRequestBodys, 'error'), requestContentType = _.get(formatRequestBodys, 'header'), requestBody = _.get(formatRequestBodys, 'body');
                                    if (!_.isEmpty(requestError)) {
                                        reject(that.ConvertResult('error', "".concat(requestError)));
                                    }
                                    if (!_.isEmpty(requestContentType)) {
                                        ctKey = _.find(_.keys(options_2.headers), function (h) { return _.toLower(h) == 'content-type'; }) || 'content-type';
                                        _.set(options_2, "headers.".concat(ctKey), requestContentType['content-type']);
                                    }
                                    if (!_.isEmpty(requestBody)) {
                                        _.assign(options_2, {
                                            body: requestBody
                                        });
                                    }
                                    // hook
                                    _.assign(options_2, {
                                        hooks: {
                                            // 处理添加请求头
                                            beforeRequest: [
                                                function (options) {
                                                    var _a;
                                                    _.forEach(__assign(__assign({ "User-Agent": "ApipostRequest/".concat((_a = module.exports) === null || _a === void 0 ? void 0 : _a.version, " (https://www.apipost.cn)") }, that.formatRequestHeaders(_.get(target, 'request.header.parameter'), _.get(target, 'request.body.mode'))), extra_headers), function (value, key) {
                                                        _.unset(options, "headers.".concat(_.toLower(key)));
                                                        that.setCaseInsensitive(options, "headers.".concat(key), value);
                                                    });
                                                }
                                            ],
                                            // 处理一些认证逻辑
                                            afterResponse: [
                                                function (response, retryWithMergedOptions) {
                                                    if (Number(response === null || response === void 0 ? void 0 : response.statusCode) == 401) {
                                                        var requestOptions = _.get(response, 'request.options');
                                                        var wwwAuthenticate = that.getCaseInsensitive(_.get(response, 'headers'), 'www-authenticate');
                                                        if (_.isString(wwwAuthenticate) && wwwAuthenticate != '') {
                                                            try {
                                                                var init_parsed = new parsers.WWW_Authenticate(that.getCaseInsensitive(_.get(response, 'request.options.headers'), 'authorization') || '');
                                                                var parsed = new parsers.WWW_Authenticate(wwwAuthenticate);
                                                                var fullUri = request_urls_1.href.substr(request_urls_1.origin.length);
                                                                if (_.toLower(parsed === null || parsed === void 0 ? void 0 : parsed.scheme) == 'digest') {
                                                                    that.setCaseInsensitive(requestOptions, 'headers.authorization', "".concat(that.getDigestAuthString(target, options_2 === null || options_2 === void 0 ? void 0 : options_2.method, fullUri, _.assign(_.get(target, 'request.auth.digest') || {}, init_parsed === null || init_parsed === void 0 ? void 0 : init_parsed.parms, parsed === null || parsed === void 0 ? void 0 : parsed.parms))));
                                                                    return retryWithMergedOptions(requestOptions);
                                                                }
                                                                else if (_.toLower(parsed === null || parsed === void 0 ? void 0 : parsed.scheme) == 'ntlm' || wwwAuthenticate.includes('NTLM')) {
                                                                    that.setCaseInsensitive(requestOptions, 'headers.authorization', "".concat(that.getNTLMAuthString(target, ntlm.parseType2Message(wwwAuthenticate), _.get(target, 'request.auth.ntlm'))));
                                                                    return retryWithMergedOptions(requestOptions);
                                                                }
                                                            }
                                                            catch (e) { }
                                                        }
                                                    }
                                                    return response;
                                                }
                                            ]
                                        }
                                    });
                                    request_urls_clone = _.cloneDeep(request_urls_1);
                                    request_urls_clone.set("query", '');
                                    request_urls_clone.set("hash", '');
                                    got_url = request_urls_clone.toString();
                                    if (query_add_equal < 1) {
                                        queryStr = "";
                                        if (request_urls_1.query !== '') {
                                            queries = qs.parse(request_urls_1.query.substr(1));
                                            queryStr = qs.stringify(Object.assign(queries, searchParams_1));
                                        }
                                        else if (!_.isEmpty(searchParams_1)) {
                                            queryStr = qs.stringify(searchParams_1);
                                        }
                                        if (queryStr) {
                                            //空无需"="
                                            queryStr = queryStr.replace(/=\&/g, ''); //替换中间的空等号
                                            queryStr = _.trimEnd(queryStr, '='); //去掉末尾的等号
                                            got_url += "?" + queryStr;
                                        }
                                    }
                                    else {
                                        if (!_.isEmpty(searchParams_1)) {
                                            _.assign(options_2, {
                                                searchParams: searchParams_1
                                            });
                                        }
                                    }
                                    // 发送
                                    that.requestLink = got(got_url, options_2).then(function (response) { return __awaiter(_this, void 0, void 0, function () {
                                        var _a, _b, _c, _d;
                                        return __generator(this, function (_e) {
                                            switch (_e.label) {
                                                case 0:
                                                    _a = reslove;
                                                    _c = (_b = that).ConvertResult;
                                                    _d = ['success', 'success'];
                                                    return [4 /*yield*/, that.formatResponseData(null, response, target)];
                                                case 1:
                                                    _a.apply(void 0, [_c.apply(_b, _d.concat([_e.sent()]))]);
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }).catch(function (error) { return __awaiter(_this, void 0, void 0, function () {
                                        var _a, _b, _c, _d;
                                        return __generator(this, function (_e) {
                                            switch (_e.label) {
                                                case 0:
                                                    _a = reject;
                                                    _c = (_b = that).ConvertResult;
                                                    _d = ['error', "".concat(String(error), "[").concat(error === null || error === void 0 ? void 0 : error.code, "]")];
                                                    return [4 /*yield*/, that.formatResponseData("".concat(String(error), "[").concat(error === null || error === void 0 ? void 0 : error.code, "]"), error.response, target)];
                                                case 1:
                                                    _a.apply(void 0, [_c.apply(_b, _d.concat([_e.sent()]))]);
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    _b.label = 9;
                                case 9: return [2 /*return*/];
                            }
                        });
                    }); })
                    // 完成重写发送逻辑
                ];
            });
        });
    };
    return ApipostRequest;
}());

module.exports = ApipostRequest;
